import json
import os
import sqlite3
from datetime import datetime
from pathlib import Path
from typing import Any, Literal

from anthropic import Anthropic
from dotenv import load_dotenv
from pydantic import BaseModel, Field
from rich.console import Console

# Import Enviromental variables
load_dotenv()

# Initialize clients
console = Console()
client = Anthropic(api_key=os.getenv("ANTHROPIC_API_KEY"))

# Configuration
MODEL_NAME = "claude-sonnet-4-20250514"
MAX_ITERATIONS = 10  # ? Not sure if I need this

# ============================================================================
#  Database Actions
# ============================================================================


def initialize_database():
    # ensure the data directory exists
    Path("data").mkdir(parents=True, exist_ok=True)

    conn = sqlite3.connect("data/tasks.db")

    cur = conn.cursor()

    cur.execute("""
        CREATE TABLE IF NOT EXISTS tasks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        description TEXT NOT NULL,
        priority TEXT NOT NULL,
        status TEXT NOT NULL,
        due_date TEXT,
        completed_date TEXT
        )
        """)

    return conn


# ============================================================================
# Pydantic Models
# ============================================================================


class Task(BaseModel):
    """Model for Indvidual Task"""

    id: int | None = Field(
        default=None, description="ID of task, autogenerated by Database"
    )
    description: str = Field(description="Task description")
    priority: Literal["low", "medium", "high"] = Field(
        description="priority of task", default="low"
    )
    status: Literal["in_progress", "completed", "on_hold"] = Field(
        default="in_progress", description="Status of task"
    )
    due_date: str | None = Field(default=None, description="Date for task completion")
    completed_date: str | None = Field(
        default=None, description="Date of task completion"
    )


class ToolResult(BaseModel):
    """Result from tool execution"""

    success: bool = Field(description="Whether tool execution succeeded")
    data: Any | None = Field(default=None, description="Tool output data")
    error: str | None = Field(default=None, description="Error message if failed")


# ============================================================================
# Basic Functions
# ============================================================================


# TODO Add error checking in case task can't be added
def add_task(conn, task: Task):
    """function to add new Task to the Database"""

    cur = conn.cursor()

    task_dict = task.model_dump()

    cur.execute(
        """INSERT INTO tasks (description, priority, status, due_date, completed_date)
           VALUES (?, ?, ?, ?, ?)""",
        (
            task_dict["description"],
            task_dict["priority"],
            task_dict["status"],
            task_dict["due_date"],
            task_dict["completed_date"],
        ),
    )
    conn.commit()


# TODO add error checking
# TODO add message if it returns none (is that needed?)
def list_tasks(conn, filters: dict = None):
    """Return list of tasks, either all or some based on filter"""
    cur = conn.cursor()
    query = "SELECT * FROM tasks"
    params = []

    if filters:
        # Only allow filtering by known columns to avoid SQL errors or injection via key
        allowed_fields = {
            "id",
            "description",
            "priority",
            "status",
            "due_date",
            "completed_date",
        }

        invalid = [k for k in filters if k not in allowed_fields]
        if invalid:
            raise ValueError(
                f"Invalid filter keys: {invalid}. "
                f"Allowed keys: {sorted(allowed_fields)}"
            )

        conditions = []
        for field, value in filters.items():
            conditions.append(f"{field} = ?")
            params.append(value)

        query += " WHERE " + " AND ".join(conditions)

    cur.execute(query, tuple(params))
    rows = cur.fetchall()
    return [tuple_to_task(row) for row in rows]


def update_task(conn, task_id: int, updates: dict):
    """Update fields of a task in the database

    Args:
        conn (_type_): Database connection
        task_id (int): ID of task to update
        updates (dict): Dict of fields to update with new values

    Raises:
        ValueError: If invalid fields are provided in updates
        ValueError: ID of task does not exist
    """
    cur = conn.cursor()

    allowed_fields = {"description", "priority", "status", "due_date", "completed_date"}
    invalid = [k for k in updates if k not in allowed_fields]
    if invalid:
        raise ValueError(f"Invalid update fields: {invalid}")

    cur.execute("SELECT id FROM tasks WHERE id = ?", (task_id,))
    if not cur.fetchone():
        raise ValueError(f"Task with id {task_id} does not exist.")

    # Build Update Query
    set_clauses = [f"{field} = ?" for field in updates]
    query = f"UPDATE tasks SET {', '.join(set_clauses)} WHERE id = ?"
    params = list(updates.values()) + [task_id]

    cur.execute(query, tuple(params))
    conn.commit()


def complete_task(conn, task_id: int):
    """Given a task ID, mark it as completed with the current date

    Args:
        conn (_type_): Database connection
        task_id (int): ID of task to mark as completed
    """
    current_date = datetime.now().strftime("%Y-%m-%d")
    update_task(conn, task_id, {"status": "completed", "completed_date": current_date})


def delete_task():
    pass


def find_task(conn, search_term: str = None, filters: dict = None):
    """Find tasks by partial description match or other criteria

    Args:
        conn: Database connection
        search_term: Text to search for in description (case-insensitive)
        filters: Additional exact-match filters (priority, status, etc.)

    Returns:
        List of matching Task objects
    """
    cur = conn.cursor()
    query = "SELECT * FROM tasks WHERE 1=1"
    params = []

    if search_term:
        query += " AND description LIKE ?"
        params.append(f"%{search_term}%")

    if filters:
        allowed_fields = {"priority", "status", "due_date", "completed_date"}
        for field, value in filters.items():
            if field in allowed_fields:
                query += f" AND {field} = ?"
                params.append(value)

    cur.execute(query, tuple(params))
    rows = cur.fetchall()
    return [tuple_to_task(row) for row in rows]


# ============================================================================
# Helper Functions
# ============================================================================


def tuple_to_task(row: tuple) -> Task:
    """Takes a tuple of task data and returns a Task Model"""
    return Task(
        id=row[0],
        description=row[1],
        priority=row[2],
        status=row[3],
        due_date=row[4],
        completed_date=row[5],
    )


# ============================================================================
# Wrapper Functions
# ============================================================================


def execute_add_task(conn, tool_input: dict) -> ToolResult:
    """Wrapper to execture add_task and return a ToolResult"""
    try:
        task = Task(
            description=tool_input["description"],
            priority=tool_input.get("priority", "low"),
            status=tool_input.get("status", "in_progress"),
            due_date=tool_input.get("due_date"),
            completed_date=tool_input.get("completed_date"),
        )

        add_task(conn, task)

        return ToolResult(
            success=True, data=f"Task add successfully: {task.description}"
        )
    except Exception as e:
        return ToolResult(success=False, error=f"Failed to add task: {str(e)}")


def execute_list_task(conn, tool_input: dict) -> ToolResult:
    try:
        # Extract filters if they exist, otherwise None (list all)
        filters = tool_input.get("filters") or None

        tasks = list_tasks(conn, filters=filters)

        # Convert Task objects to dicts for JSON
        tasks_data = [task.model_dump() for task in tasks]

        return ToolResult(success=True, data=tasks_data)
    except Exception as e:
        return ToolResult(success=False, error=f"Failed to list task: {str(e)}")


def execute_update_task(conn, tool_input: dict) -> ToolResult:
    try:
        task_id = tool_input["task_id"]
        updates = tool_input.get("updates", {})

        if not updates:
            return ToolResult(success=False, error="No updates provided")

        # TODO add date validation (need to add function)

        update_task(conn, task_id, updates)
        return ToolResult(success=True, data=f"Task {task_id} updated successfully")

    except Exception as e:
        return ToolResult(success=False, error=f"Failed to update task: {str(e)}")


def execute_complete_task():
    pass


def execute_delete_task():
    pass


def execute_find_task(conn, tool_input: dict) -> ToolResult:
    """Wrapper to execute find_task"""
    try:
        search_term = tool_input.get("search_term")
        filters = tool_input.get("filters")

        if not search_term and not filters:
            return ToolResult(success=False, error="Provide search_term or filters")

        tasks = find_task(conn, search_term=search_term, filters=filters)

        if not tasks:
            return ToolResult(
                success=True,
                data={"tasks": [], "message": "No tasks found matching criteria"},
            )

        tasks_data = [task.model_dump() for task in tasks]
        return ToolResult(success=True, data={"tasks": tasks_data, "count": len(tasks)})

    except Exception as e:
        return ToolResult(success=False, error=f"Failed to find task: {str(e)}")


# ============================================================================
# Tools
# ============================================================================

TOOLS = [
    {
        "name": "add_task",
        "description": (
            "Adds a new task to the task manager. "
            "Use this when the user wants to create, add, or remember a task. "
            "Tasks can have different priorities (low, medium, high) and "
            "can optionally include due dates."
        ),
        "input_schema": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Clear description of what needs to be done",
                },
                "priority": {
                    "type": "string",
                    "enum": ["low", "medium", "high"],
                    "description": "Task priority level",
                    "default": "low",
                },
                "status": {
                    "type": "string",
                    "enum": ["in_progress", "completed", "on_hold"],
                    "description": "Current status of the task",
                    "default": "in_progress",
                },
                "due_date": {
                    "type": "string",
                    "description": "Optional due date for task (format: YYYY-MM-DD)",
                },
                "completed_date": {
                    "type": "string",
                    "description": "Date when task was completed (format: YYYY-MM-DD)",
                },
            },
            "required": ["description"],
        },
    },
    {
        "name": "list_tasks",
        "description": (
            "Lists tasks from the task manager."
            "Can list all tasks or filter by specific criteria"
            "like priority, status, or due date."
        ),
        "input_schema": {
            "type": "object",
            "properties": {
                "filters": {
                    "type": "object",
                    "description": "Optional filters to apply. Empty to list all.",
                    "properties": {
                        "priority": {
                            "type": "string",
                            "enum": ["low", "medium", "high"],
                            "description": "Filter by task priority",
                        },
                        "status": {
                            "type": "string",
                            "enum": ["in_progress", "completed", "on_hold"],
                            "description": "Filter by task status",
                        },
                        "due_date": {
                            "type": "string",
                            "description": "Filter by due date (format: YYYY-MM-DD)",
                        },
                    },
                }
            },
        },
    },
    {
        "name": "update_task",
        "description": (
            "Updates an existing task's properties. "
            "Can update description, priority, status, or dates. "
            "Only provide the fields you want to change."
        ),
        "input_schema": {
            "type": "object",
            "properties": {
                "task_id": {
                    "type": "integer",
                    "description": "ID of the task to update",
                },
                "updates": {
                    "type": "object",
                    "description": "Fields to update",
                    "properties": {
                        "description": {"type": "string"},
                        "priority": {
                            "type": "string",
                            "enum": ["low", "medium", "high"],
                        },
                        "status": {
                            "type": "string",
                            "enum": ["in_progress", "completed", "on_hold"],
                        },
                        "due_date": {"type": "string"},
                        "completed_date": {"type": "string"},
                    },
                },
            },
            "required": ["task_id", "updates"],
        },
    },
    {
        "name": "find_task",
        "description": (
            "Search for tasks by description or other properties. "
            "Use this to find task IDs when the user refers to tasks by their content "
            "(e.g., 'my grocery task', 'the meeting task'). "
            "Returns all matching tasks with their IDs."
        ),
        "input_schema": {
            "type": "object",
            "properties": {
                "search_term": {
                    "type": "string",
                    "description": (
                        "Text to search for in task description"
                        "(partial match, case-insensitive)"
                    ),
                },
                "filters": {
                    "type": "object",
                    "description": "Additional filters to narrow results",
                    "properties": {
                        "priority": {
                            "type": "string",
                            "enum": ["low", "medium", "high"],
                        },
                        "status": {
                            "type": "string",
                            "enum": ["in_progress", "completed", "on_hold"],
                        },
                        "due_date": {"type": "string"},
                    },
                },
            },
        },
    },
]

TOOL_MAP = {
    "add_task": execute_add_task,
    "list_tasks": execute_list_task,
    "update_task": execute_update_task,
    "find_task": execute_find_task,
}


# ============================================================================
# AI Agent
# ============================================================================
def process_tool_call(conn, tool_name: str, tool_input: dict) -> ToolResult:
    """Execute a tool and return the result"""
    if tool_name not in TOOL_MAP:
        return ToolResult(success=False, error=f"Unknown tool: {tool_name}")

    tool_func = TOOL_MAP[tool_name]
    return tool_func(conn, tool_input)


def run_agent(conn, user_message: str) -> str:
    """
    Run the agentic loop: send message to Claude, process tool calls, return response.

    Args:
        user_message: Users input query

    Returns:
        Claude's final response as a string
    """
    messages = [{"role": "user", "content": user_message}]
    current_date = datetime.now().strftime("%Y-%m-%d")

    for iteration in range(MAX_ITERATIONS):
        console.print(f"\n[dim]--- Iteration {iteration + 1} ---[/dim]")

        try:
            # Call Claude API
            response = client.messages.create(
                model=MODEL_NAME,
                max_tokens=4096,
                tools=TOOLS,
                messages=messages,
                system=(
                    "You are a helpful task management assistant. "
                    f"The current date is {current_date}. "
                    "Help users manage their tasks by adding, viewing, and organizing them. "
                    "Be friendly and conversational. "
                    "IMPORTANT: When users refer to tasks by description "
                    "(e.g., 'complete my grocery task'), "
                    "first use find_task or list_tasks to locate the task and get its ID. "
                    "If multiple tasks match, "
                    "show them to the user and ask which one they meant. "
                    "Then use the ID for update_task, complete_task, "
                    "or delete_task operations."
                ),
            )

            # TODO This is for debugging during testing to see what tools are being used
            console.print(f"[dim]Stop reason: {response.stop_reason}[/dim]")

            # Check if Claude needs a tool
            if response.stop_reason == "tool_use":
                assistant_message = {"role": "assistant", "content": response.content}
                messages.append(assistant_message)

                tool_results = []

                for block in response.content:
                    if block.type == "tool_use":
                        tool_name = block.name
                        tool_input = block.input

                        console.print(
                            f"[yellow]Calling tool: {tool_name} "
                            f"({json.dumps(tool_input, indent=2)})[/yellow]"
                        )

                        result = process_tool_call(conn, tool_name, tool_input)

                        tool_results.append(
                            {
                                "type": "tool_result",
                                "tool_use_id": block.id,
                                "content": json.dumps(
                                    {
                                        "success": result.success,
                                        "data": result.data,
                                        "error": result.error,
                                    }
                                ),
                            }
                        )

                messages.append({"role": "user", "content": tool_results})

                # Continue the loop to get Claude's next response
                continue

            elif response.stop_reason == "end_turn":
                # Claude finished and provided a response
                final_response = ""
                for block in response.content:
                    if hasattr(block, "text"):
                        final_response += block.text

                return final_response

            else:
                return f"Unexpected stop reason: {response.stop_reason}"

        except Exception as e:
            console.print(f"[red]Error calling Claude: {str(e)}[/red]")
            return f"Error: {str(e)}"

    return "Maximum iterations reached. Please try again with a more specific query"


# ============================================================================
# Main Application
# ============================================================================


def main():
    # Check if Claude API key is set
    if not os.getenv("ANTHROPIC_API_KEY"):
        console.print("[red]âœ— ANTHROPIC_API_KEY not found in environment[/red]")
        console.print("[yellow]Add it to your .env file[/yellow]")
        return

    conn = initialize_database()
    try:
        console.print("[bold green]Task Manager Agent Started! [/bold green]")
        console.print(f"[dim]Using Model: {MODEL_NAME}[/dim]")
        console.print("Type 'exit' or 'quit to end.\n")

        while True:
            user_input = input("You: ")
            if user_input.lower() in ["exit", "quit"]:
                break

            response = run_agent(conn, user_input)
            console.print(f"[blue]Agent:[/blue] {response}\n")
    finally:
        conn.close()


if __name__ == "__main__":
    main()
