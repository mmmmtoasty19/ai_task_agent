import json
import os
import sqlite3
from datetime import datetime
from pathlib import Path
from typing import Any, Literal

from anthropic import Anthropic
from dotenv import load_dotenv
from pydantic import BaseModel, Field
from rich.console import Console

# Import Enviromental variables
load_dotenv()

# Initialize clients
console = Console()
client = Anthropic(api_key=os.getenv("ANTHROPIC_API_KEY"))

# Configuration
MODEL_NAME = "claude-sonnet-4-20250514"
MAX_ITERATIONS = 10  # ? Not sure if I need this

# ============================================================================
#  Database Actions
# ============================================================================


def initialize_database():
    # ensure the data directory exists
    Path("data").mkdir(parents=True, exist_ok=True)

    conn = sqlite3.connect("data/tasks.db")

    cur = conn.cursor()

    cur.execute("""
        CREATE TABLE IF NOT EXISTS tasks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        description TEXT NOT NULL,
        priority TEXT NOT NULL,
        status TEXT NOT NULL,
        due_date TEXT,
        completed_date TEXT
        )
        """)

    return conn


# ============================================================================
# Pydantic Models
# ============================================================================


class Task(BaseModel):
    """Model for Indvidual Task"""

    id: int | None = Field(
        default=None, description="ID of task, autogenerated by Database"
    )
    description: str = Field(description="Task description")
    priority: Literal["low", "medium", "high"] = Field(
        description="priority of task", default="low"
    )
    status: Literal["in_progress", "completed", "on_hold"] = Field(
        default="in_progress", description="Status of task"
    )
    due_date: str | None = Field(default=None, description="Date for task completion")
    completed_date: str | None = Field(
        default=None, description="Date of task completion"
    )


class ToolResult(BaseModel):
    """Result from tool execution"""

    success: bool = Field(description="Whether tool execution succeeded")
    data: Any | None = Field(default=None, description="Tool output data")
    error: str | None = Field(default=None, description="Error message if failed")


# ============================================================================
# Basic Functions
# ============================================================================


# TODO Add error checking in case task can't be added
def add_task(conn, task: Task):
    """function to add new Task to the Database"""

    cur = conn.cursor()

    task_dict = task.model_dump()

    cur.execute(
        """INSERT INTO tasks (description, priority, status, due_date, completed_date)
           VALUES (?, ?, ?, ?, ?)""",
        (
            task_dict["description"],
            task_dict["priority"],
            task_dict["status"],
            task_dict["due_date"],
            task_dict["completed_date"],
        ),
    )
    conn.commit()


# TODO add error checking
# TODO add message if it returns none (is that needed?)
def list_tasks(conn, filters: dict = None):
    """Return list of tasks, either all or some based on filter"""
    cur = conn.cursor()
    query = "SELECT * FROM tasks"
    params = []

    if filters:
        # Only allow filtering by known columns to avoid SQL errors or injection via key
        allowed_fields = {
            "id",
            "description",
            "priority",
            "status",
            "due_date",
            "completed_date",
        }

        invalid = [k for k in filters if k not in allowed_fields]
        if invalid:
            raise ValueError(
                f"Invalid filter keys: {invalid}. "
                f"Allowed keys: {sorted(allowed_fields)}"
            )

        conditions = []
        for field, value in filters.items():
            conditions.append(f"{field} = ?")
            params.append(value)

        query += " WHERE " + " AND ".join(conditions)

    cur.execute(query, tuple(params))
    rows = cur.fetchall()
    return [tuple_to_task(row) for row in rows]


def update_task(conn, task_id: int, updates: dict):
    """Update fields of a task in the database

    Args:
        conn (_type_): Database connection
        task_id (int): ID of task to update
        updates (dict): Dict of fields to update with new values

    Raises:
        ValueError: If invalid fields are provided in updates
        ValueError: ID of task does not exist
    """
    cur = conn.cursor()

    allowed_fields = {"description", "priority", "status", "due_date", "completed_date"}
    invalid = [k for k in updates if k not in allowed_fields]
    if invalid:
        raise ValueError(f"Invalid update fields: {invalid}")

    cur.execute("SELECT id FROM tasks WHERE id = ?", (task_id,))
    if not cur.fetchone():
        raise ValueError(f"Task with id {task_id} does not exist.")

    # Build Update Query
    set_clauses = [f"{field} = ?" for field in updates]
    query = f"UPDATE tasks SET {', '.join(set_clauses)} WHERE id = ?"
    params = list(updates.values()) + [task_id]

    cur.execute(query, tuple(params))
    conn.commit()


def complete_task():
    pass


def delete_task():
    pass


# ============================================================================
# Helper Functions
# ============================================================================


def tuple_to_task(row: tuple) -> Task:
    """Takes a tuple of task data and returns a Task Model"""
    return Task(
        id=row[0],
        description=row[1],
        priority=row[2],
        status=row[3],
        due_date=row[4],
        completed_date=row[5],
    )


# ============================================================================
# Wrapper Functions
# ============================================================================


def execute_add_task(conn, tool_input: dict) -> ToolResult:
    """Wrapper to execture add_task and return a ToolResult"""
    try:
        task = Task(
            description=tool_input["description"],
            priority=tool_input.get("priority", "low"),
            status=tool_input.get("status", "in_progress"),
            due_date=tool_input.get("due_date"),
            completed_date=tool_input.get("completed_date"),
        )

        add_task(conn, task)

        return ToolResult(
            success=True, data=f"Task add successfully: {task.description}"
        )
    except Exception as e:
        return ToolResult(success=False, error=f"Failed to add task: {str(e)}")


def execute_list_task(conn, tool_input: dict) -> ToolResult:
    try:
        # Extract filters if they exist, otherwise None (list all)
        filters = tool_input.get("filters") or None

        tasks = list_tasks(conn, filters=filters)

        # Convert Task objects to dicts for JSON
        tasks_data = [task.model_dump() for task in tasks]

        return ToolResult(success=True, data=tasks_data)
    except Exception as e:
        return ToolResult(success=False, error=f"Failed to list task: {str(e)}")


# ============================================================================
# Tools
# ============================================================================

TOOLS = [
    {
        "name": "add_task",
        "description": (
            "Adds a new task to the task manager. "
            "Use this when the user wants to create, add, or remember a task. "
            "Tasks can have different priorities (low, medium, high) and "
            "can optionally include due dates."
        ),
        "input_schema": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Clear description of what needs to be done",
                },
                "priority": {
                    "type": "string",
                    "enum": ["low", "medium", "high"],
                    "description": "Task priority level",
                    "default": "low",
                },
                "status": {
                    "type": "string",
                    "enum": ["in_progress", "completed", "on_hold"],
                    "description": "Current status of the task",
                    "default": "in_progress",
                },
                "due_date": {
                    "type": "string",
                    "description": "Optional due date for task (format: YYYY-MM-DD)",
                },
                "completed_date": {
                    "type": "string",
                    "description": "Date when task was completed (format: YYYY-MM-DD)",
                },
            },
            "required": ["description"],
        },
    },
    {
        "name": "list_tasks",
        "description": "Lists tasks from the task manager. Can list all tasks or filter by specific criteria like priority, status, or due date.",
        "input_schema": {
            "type": "object",
            "properties": {
                "filters": {
                    "type": "object",
                    "description": "Optional filters to apply. Leave empty to list all tasks.",
                    "properties": {
                        "priority": {
                            "type": "string",
                            "enum": ["low", "medium", "high"],
                            "description": "Filter by task priority",
                        },
                        "status": {
                            "type": "string",
                            "enum": ["in_progress", "completed", "on_hold"],
                            "description": "Filter by task status",
                        },
                        "due_date": {
                            "type": "string",
                            "description": "Filter by due date (format: YYYY-MM-DD)",
                        },
                    },
                }
            },
        },
    },
]

TOOL_MAP = {"add_task": execute_add_task, "list_tasks": execute_list_task}


# ============================================================================
# AI Agent
# ============================================================================
def process_tool_call(conn, tool_name: str, tool_input: dict) -> ToolResult:
    """Execute a tool and return the result"""
    if tool_name not in TOOL_MAP:
        return ToolResult(success=False, error=f"Unknown tool: {tool_name}")

    tool_func = TOOL_MAP[tool_name]
    return tool_func(conn, tool_input)


def run_agent(conn, user_message: str) -> str:
    """
    Run the agentic loop: send message to claude, process tool calls, return response.

    Args:
        user_message: Users input query

    Returns:
        Claudes's final response as a string
    """
    messages = [{"role": "user", "content": user_message}]
    current_date = datetime.now().strftime("%Y-%m-%d")

    for iteration in range(MAX_ITERATIONS):
        console.print(f"\n[dim]--- Iteration {iteration + 1} ---[/dim]")

        # Call Claude API
        response = client.messages.create(
            model=MODEL_NAME,
            max_tokens=4096,
            tools=TOOLS,
            messages=messages,
            system=(
                "You are a helpful task management assistant. "
                f"The current date is {current_date} "
                "Help users manage their tasks by adding, viewing, and organizing them."
                " Be friendly and conversational. "
            ),
        )

        # TODO This is for Debugging, Can remove later
        console.print(f"[dim]Stop reason: {response.stop_reason}[/dim]")

        # Check is Claude needs a tool
        if response.stop_reason == "tool_use":
            assistant_message = {"role": "assistant", "content": response.content}
            messages.append(assistant_message)

            tool_results = []

            for block in response.content:
                if block.type == "tool_use":
                    tool_name = block.name
                    tool_input = block.input

                    console.print(
                        f"[yellow] Calling tool: {tool_name}"
                        f"({json.dumps(tool_input, indent=2)})[/yellow]"
                    )

                    result = process_tool_call(conn, tool_name, tool_input)

                    tool_results.append(
                        {
                            "type": "tool_result",
                            "tool_use_id": block.id,
                            "content": json.dumps(
                                {
                                    "success": result.success,
                                    "data": result.data,
                                    "error": result.error,
                                }
                            ),
                        }
                    )

            messages.append({"role": "user", "content": tool_results})

            # Continue the loop to get Claudes next response
        elif response.stop_reason == "end_turn":
            # Claude finished the loop and provided a response
            final_response = ""
            for block in response.content:
                if hasattr(block, "text"):
                    final_response += block.text

            return final_response

        else:
            return f"Unexpected stop reason: {response.stop_reason}"

    return "Maximum iterations reached. Please try again with a more specific query"


# ============================================================================
# Main Application
# ============================================================================


def main():
    conn = initialize_database()
    try:
        console.print("[bold green]Task Manager Agent Started! [/bold green]")
        console.print("Type 'exit' or 'quit to end.\n")

        while True:
            user_input = input("You: ")
            if user_input.lower() in ["exit", "quit"]:
                break

            response = run_agent(conn, user_input)
            console.print(f"[blue]Agent:[/blue] {response}\n")
    finally:
        conn.close()


if __name__ == "__main__":
    main()
